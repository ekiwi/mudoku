classdef HardwareScanner < AbstractScanner
    % HardwareScanner
    %
    % Syntax
    %
    % Description
    %   Implements the AbstractScanner interface with
    %   real hardware.
    %
    %
    % Signature
    %   Author: Johannes, Martin, Kevin, Florian
    %   Date: 2012/12/17
    %   Copyright: 2012-2014, RWTH Aachen University
    
    properties (GetAccess = 'private', SetAccess = 'private')
        hw = 0;
    end
    
    methods(Access = 'private')
        
        % Scan a whole area
        % x: Start (Left/Right)
        % y: Start (Forwards/Backwards)
        % width: Steps right
        % height: Steps forward
        % xStep: Size of steps right
        function rawImageData = scanArea(obj, x, y, width, height, xStep)
            
            rawImageData = [];
            pos = [0, 0];   % xPosition and yPosition
            obj.hw.moveToXY(x, y);  % x and y changed
            
            while(pos(1) < width)
                
                %% START: Move Forwards
                obj.hw.moveForwards(0);
                
                while(pos(2)<height)
                    [a, b] = obj.hw.getPosition(); 
                    pos(1) = a-x;  
                    pos(2) = b-y;  
                    if(pos(1)<1) pos(1) = 1; end % No negative positions allowed
                    if(pos(2)<1) pos(2) = 1; end
                    
                    rawImageData = [rawImageData, [pos(1); pos(2); obj.hw.getBrightness1()]];
                    rawImageData = [rawImageData, [pos(1)+370; pos(2); obj.hw.getBrightness2()]];
                    rawImageData = [rawImageData, [pos(1)+740; pos(2); obj.hw.getBrightness3()]];
                end
                
                obj.hw.motorX1.Stop('HoldBrake', obj.hw.nxtHandle1);
                obj.hw.motorX2.Stop('HoldBrake', obj.hw.nxtHandle1);
                %% END
                
                % Abort if end has been reached
                if(pos(1)+xStep>=width)
                    break;
                end
                obj.hw.moveRightW(xStep);
                    
                                
                %% START: Move Backwards
                obj.hw.moveBackwards(0);
                
                while(pos(2)>1)
                    [a, b] = obj.hw.getPosition(); 
                    pos(1) = a-x;  
                    pos(2) = b-y;  
                    if(pos(1)<1) pos(1) = 1; end % No negative positions allowed
                    if(pos(2)<1) pos(2) = 1; end
                    
                    rawImageData = [rawImageData, [pos(1); pos(2); obj.hw.getBrightness1()]];
                    rawImageData = [rawImageData, [pos(1)+370; pos(2); obj.hw.getBrightness2()]];
                    rawImageData = [rawImageData, [pos(1)+740; pos(2); obj.hw.getBrightness3()]];
                end
                
                obj.hw.motorX1.Stop('HoldBrake', obj.hw.nxtHandle1);
                obj.hw.motorX2.Stop('HoldBrake', obj.hw.nxtHandle1);
                %% END
                
                obj.hw.moveRightW(xStep);
                [a, b] = obj.hw.getPosition(); 
                pos(1) = a-x;  
                pos(2) = b-y; 
                if(pos(1)<1) pos(1) = 1; end % No negative positions allowed
                if(pos(2)<1) pos(2) = 1; end
                    
            end
            
        end
        
        % Scales the X-Values, Y-Values, Brightness-Values
        % Returns the rawImageData which contains the updated data
        % Also includes the xScale, xMin and yScale, yMin values:
        %   x_new * xScale + xMin = x_old
        %   y_new * yScale + yMin = y_old         
        function [imageData xScale xMin yScale yMin] = scaleRawImageData(obj, imageData_in, xRes, yRes)
            minBright = min(imageData_in(3,:));
            maxBright = max(imageData_in(3,:));
            imageData = imageData_in;
            imageData(3,:) = (imageData_in(3,:)-minBright) ./ (maxBright-minBright) .* 255;
            
            minX = min(imageData(1, :));
            maxX = max(imageData(1, :));
            minY = min(imageData(2, :));
            maxY = max(imageData(2, :));
            
            xScale = (maxX-minX)/xRes;
            xMin = minX;
            yScale = (maxY-minY)/yRes;
            yMin = minY;
            
            image(1,:) = round((image(1,:) - minX) ./ xScale);
            image(2,:) = round((image(2,:) - minY) ./ xScale);

        end
        
        % Calculates the real positions of the machine from the positions
        % in an image
        function [x y] = calcOldPosition(obj, x_new, y_new, xScale, yScale, xMin, yMin)
            x = x_new*xScale+xMin;
            y = y_new*yScale+yMin;
        end
        
        
        % Takes the raw image data generated by scanArea and produces a
        % gray image
        function rawGrayImage = createGrayImageFromRawData(obj, imageData)
            
            numEntries = length(imageData(1, :));
            minX = min(imageData(1, :));
            maxX = max(imageData(1, :));
            minY = min(imageData(2, :));
            maxY = max(imageData(2, :));
            
            width = maxX-minX;
            height= maxY-minY;
            
            % create NaN matrix
            rawGrayImage = ones(width, height)*NaN;
            % NaN is used to identify which pixels have not been set
            
            for i=1:numEntries
                
                x = imageData(1,i);
                y = imageData(2,i);
                                
                if(isnan(rawGrayImage(x, y)))
                    rawGrayImage(x, y) = imageData(3, i);
                else
                    rawGrayImage(x, y) = 0.5*(rawGrayImage(x, y)+imageData(3, i));
                end
                
            end
            
        end
    end
    
    methods
        function obj = HardwareScanner(hal)
            obj.hw = hal;
        end

        function firstScan(obj)
            disp('First Scan...');
        end

        function secondScan(obj)
            disp('Second Scan...');
            
            rawImageData = obj.scanArea(0,0,obj.hw.maxStepsWidth, 200, 50);
            
            [imageData xScale xMin yScale yMin] = scaleRawImageData(rawImageData, 200, 100);
            
            grayRawImage = createGrayImageFromRawData(imageData);
            
            
            
            minBright = min(image(3,:));
            maxBright = max(image(3,:));
            image(3,:) = (image(3,:)-minBright) ./ (maxBright-minBright) .* 255;

            maxX = max(image(1,:));
            minX = min(image(1,:));
            maxY = max(image(2,:));
            minY = min(image(2,:));

            xResolution = 200;
            yResolution = 200;

            image(1,:) = (image(1,:) - minX) ./ (maxX-minX) .* (xResolution-1)+1;
            image(2,:) = (image(2,:) - minY) ./ (maxY-minY) .* (yResolution-1)+1;

            imageMatrix = ones(xResolution+1, yResolution+1)*NaN;

            figure(2);
            hold on;
            plot(image(1,:),image(2,:));
            image(1,:) = round(image(1,:));
            image(2,:) = round(image(2,:));
            plot(image(1,:),image(2,:));

            for i=1:length(image(1,:))
                x = image(1,i);
                y = image(2,i);
                if(isnan(imageMatrix(x, y)))
                    imageMatrix(x, y) = image(3, i);
                else
                    imageMatrix(x, y) = 0.5*(imageMatrix(x, y)+image(3, i));
                end
            end

            figure(3);

            for x=1:xResolution
                for y=2:yResolution
                    if(isnan(imageMatrix(x, y)))
                        imageMatrix(x, y) = imageMatrix(x, y-1);
                    end
                end
            end

            for y=1:yResolution
                for x=2:xResolution
                    if(isnan(imageMatrix(x, y)))
                        imageMatrix(x, y) = imageMatrix(x-1, y);
                    end
                end
            end

            imshow(uint8(imageMatrix))


            ableitungH = diff(imageMatrix);
            ableitungV = diff(imageMatrix');
            

%             negativeValues = find(image(1,:)<0);
%             image(:, negativeValues) = zeros( [3,length(negativeValues)]);
% 
%             matrix2D
% 
%             numXY = length(image(3,:));
% 
%             maxX = max(image(1,:));
%             maxY = max(image(2,:));
% 
%             imageMatrix = [];
% 
%             for x=1:maxX
%                 sameX = find(image(1,:) == x);    
%                 [r c] = size(sameX);    
%                 if(c == 0 && r == 0)
%                     continue;
%                 end
%                 
%                 buffer1 = image(:,sameX);
%                 for y=1:maxY
%                     sameY = find(buffer1(2,:) == y);
%                     [r c] = size(sameY);    
%                     if(c == 0 && r == 0)
%                         imageMatrix(x, buffer1(2,:)) = buffer1(3,:);
%                     else
%                         buffer2 = image(:, sameY);  
%                         color = mean(buffer2(3,:));
%                         imageMatrix(x, y) = color;
%                     end
%                 end
%             end
% 
%             imshow(imageMatrix);

        end

        function scanCells(obj)
            disp('Scanning Cells...');
        end
    end

end

